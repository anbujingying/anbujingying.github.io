---
title: 2291.序列
categories:
  - JZOJ
  - JZ初中OJ
tags:
  - OJ
---

## input:**seq.in**   output:**seq.out**

时间限制: 1000 ms  空间限制: 524288 KB

## 题目描述

有一个长度为n的序列A，其中有m个位置是1，其余位置全是0。你可以选择不超过k个区间，满足所有是1的位置都被至少一个区间覆盖。对于一个区间[l,r]，我们定义它的长度为r-l+1，求满足条件的最小区间长度之和。



## 输入

第一行三个整数m,n,k，意义如上。
接下来m行，每行一个整数x，表示Ax是1。保证输入的x递增。

## 输出

输出一行一个整数，表示满足条件的最小区间长度之和。

## 样例输入

```
4 100 2
20 30 75 80
```

## 样例输出

```
17
```

## 数据范围限制

对于20%的数据，m,k≤10,n≤100;
对于50%的数据，m,k≤2000,n≤109;
对于100%的数据，m,k≤200000,n≤109。

## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,k,p,u=1,ans,now,last,c[200001];
bool cmp(int x,int y)
{
    return x<y;
}
int main()
{
    freopen("seq.in","r",stdin);
    freopen("seq.out","w",stdout);
    scanf("%d%d%d",&m,&n,&k);
    for(int i=1;i<=m;i++)
    {
        scanf("%d",&now);
        if(now!=last+1)
        {
            if(i!=1)
            {            
                p++;
                c[p]=now-last-1;
            }
        }
        last=now;
    }
    sort(c+1,c+1+p,cmp);
    while(k<p+1)
    {
        ans+=c[u];
        u++;
        p--;
    }
    printf("%d",ans+m);
    return 0;
}
```

