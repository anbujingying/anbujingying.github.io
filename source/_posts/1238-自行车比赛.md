---
title: 1238.自行车比赛
categories:
  - JZOJ
  - JZ高中OJ
tags:
  - OJ
---

Time Limits: **1000 ms**  Memory Limits: **65536 KB**

## Description

自行车赛在一个很大的地方举行，有N个镇，用1到N编号，镇与镇之间有M条单行道相连，起点设在镇1，终点设在镇2。
问从起点到终点一共有多少种不同的路线。两条路线只要不使用完全相同的道路就被认为是不同的。



## Input

第一行两个整数：N和M(1<=N<=10000,1<=M<=100000)，表示镇的数量和道路的数量。
接下来M行，每行包含两个不同的整数A和B，表示有一条从镇A到镇B的单行道。
两个镇之间有可能不止一条路连接。

## Output

输出不同路线的数量，如果答案超过9位，只需输出最后9位数字。如果有无穷多的路线，输出“inf”。

## Sample Input

```
输入1：
6 7 
1 3 
1 4 
3 2 
4 2 
5 6 
6 5 
3 4 

输入2：
6 8 
1 3 
1 4 
3 2 
4 2 
5 6 
6 5 
3 4 
4 3 

输入3：
31 60 
1 3 
1 3 
3 4 
3 4 
4 5 
4 5 
5 6 
5 6 
6 7 
6 7 
… 
… 
… 
28 29 
28 29 
29 30 
29 30 
30 31 
30 31 
31 2 
31 2 
```

## Sample Output

```
输出1：
3

输出2：
inf

输出3：
073741824 
```

## Data Constraint



## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define N 10005
#define M 100005
int n, m, u, v, tot, tot1, ans, cir, ok, p = 1000000000;
int to[M], nxt[M], head[N], vis[N], sum[N];
int to1[M], nxt1[M], head1[N], vis1[N];
void add(int uu, int vv) {
    to[++tot] = vv; nxt[tot] = head[uu]; head[uu] = tot;
    to1[++tot1] = uu; nxt1[tot1] = head1[vv]; head1[vv] = tot1;
}
void dfs1(int x) {
    if (x == 2 || vis[x]) return;
    vis[x] = 1;
    for (int i = head[x]; i; i = nxt[i])
        dfs1(to[i]);
}
void dfs2(int x) {
    if (x == 1) return;
    if (vis1[x] == 1) {
        if (vis[x]) cir = 1;
        return;
    }
    vis1[x] = 1;
    for (int i = head1[x]; i; i = nxt1[i]) {
        if (vis1[to1[i]] != 2) dfs2(to1[i]);
        if (cir) return;
    }
    vis1[x] = 2;
}
int dfs(int x) {
    if (x == 2) return 1;
    if (vis[x]) return sum[x];
    vis[x] = 1;
    for (int i = head[x]; i; i = nxt[i]) {
        sum[x] += dfs(to[i]);
        if (sum[x] >= p) sum[x] %= p, ok = 1;
    }
    return sum[x];
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &u, &v);
        add(u, v);
    }
    dfs1(1); dfs2(2);
    if (cir) {printf("inf\n"); return 0;}
    memset(vis, 0, sizeof vis);
    ans = dfs(1);
    if (ok) {
        int num = 0; p /= 10;
        while (!(ans / p) && p) p /= 10, num++;
        while (num--) printf("0");
    }
    printf("%d\n", ans);
    return 0;
}
```

