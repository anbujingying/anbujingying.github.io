---
title: 1237.餐桌
categories:
  - JZOJ
  - JZ高中OJ
tags:
  - OJ
---

Time Limits: **1000 ms**  Memory Limits: **65536 KB**   

## Description

你家刚买了一套新房，想邀请朋友回来庆祝，所以需要一个很大的举行餐桌，餐桌能容纳的人数等于餐桌的周长，你想买一个能容纳最多人的餐桌，餐桌的边必须跟房间的边平行。
给你的房间的设计，计算最多能邀请的客人数。



## Input

第一行包含两个整数R和C(1<=R,C<=2000)，表示房子的长和宽。
接下来R行每行S个字符（中间没有空格），“.”表示空白区域，“X”表示有障碍物，餐桌所占区域必须是空白的。

## Output

输出最多能要求的客人数量。

## Sample Input

```
输入1：
2 2
..
..

输入2：
4 4 
X.XX 
X..X 
..X. 
..XX 

输入3：
3 3 
X.X 
.X. 
X.X 
```

## Sample Output

```
输出1：
7

输出2：
9

输出3：
3
```

## Data Constraint



## Hint

【数据规模】
50%的数据R,C<=400
70%的数据R,C<=1000
100%的数据，R,C<=2000

## Code

```cpp
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define N 2005
int n, m, ans;
int f[N][N], s[N], l[N];
char x;
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            scanf(" %c", &x);
            if (x == '.') f[i][j] = f[i - 1][j] + 1;
        }
    for (int i = 1; i <= n; i++) {
        int top = 0, len;
        for (int j = 1; j <= m; j++) {
            len = 0;
            while (s[top] > f[i][j] && top) {
                len += l[top];
                ans = max(ans, s[top] + len);
                top--;
            }
            if (f[i][j]) {
                s[++top] = f[i][j];
                l[top] = len + 1;
            }
        }
        len = 0;
        while (top) {
            len += l[top];
            ans = max(ans, s[top] + len);
            top--;
        }
    }
    printf("%d\n", ans * 2 - 1);
    return 0;
}
```

