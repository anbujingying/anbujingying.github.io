---
title: 1235.洪水
categories:
  - JZOJ
  - JZ高中OJ
tags:
  - OJ
---

Time Limits: **1000 ms**  Memory Limits: **65536 KB**

## Description

一天，	一个画家在森林里写生，突然爆发了山洪，他需要尽快返回住所中，那里是安
全的。
森林的地图由R行C列组成，空白区域用点“.”表示，洪水的区域用“*”表示，而
岩石用“X”表示，另画家的住所用“D”表示，画家用“S”表示。
有以下几点需要说明：
1、	每一分钟画家能向四个方向移动一格（上、下、左、右）
2、	每一分钟洪水能蔓延到四个方向的相邻格子（空白区域）
3、	洪水和画家都不能通过岩石区域
4、	画家不能通过洪水区域（同时也不行，即画家不能移到某个格子，该格子在画家达到的同时被洪水蔓延到了，这也是不允许的）
5、	洪水蔓不到画家的住所。
给你森林的地图，编写程序输出最少需要花费多长时间才能从开始的位置赶回家中。



## Input

输入第一行包含两个整数R和C(R,C<=50)。
接下来R行每行包含C个字符(“.”、“*”、“X”、“D”或“S”)。地图保证只有一个“D”和一个“S”。

## Output

输出画家最快安全到达住所所需的时间，如果画家不可能安全回家则输出“KAKTUS”。

## Sample Input

```
输入1：
3 3 
D.* 
... 
.S. 

输入2：
3 3 
D.* 
...
..S

输入3：
3 6 
D...*. 
.X.X.. 
....S. 
```

## Sample Output

```
输出1：
3

输出2：
KAKTUS 

输出3：
6
```

## Data Constraint



## Code

```cpp
#include <iostream>
#include <stdio.h>
#include <string.h>
#include <algorithm>
#include <queue>
using namespace std;
#define ll long long
#define inf 0x3f3f3f3f
#define N 55
int n, m, x0, y0, x1, y1;
int t[N][N], d[N][N], vis[N][N];
int dir[4][2] = {0, 1, 1, 0, 0, -1, -1, 0};
char g[N][N];
struct Point {
    int x, y;
} p;
bool check(int x, int y) {
    if (x < 1 || x > n) return false;
    if (y < 1 || y > m) return false;
    if (g[x][y] == 'X') return false;
    return true;
}
void bfs(int x, int y) {
    queue<Point> q;
    t[x][y] = 0;
    p.x = x; p.y = y; q.push(p);
    while (!q.empty()) {
        Point temp = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int dx = temp.x + dir[i][0];
            int dy = temp.y + dir[i][1];
            if (check(dx, dy) && g[dx][dy] != 'D')
                if (t[temp.x][temp.y] + 1 < t[dx][dy]) {
                    t[dx][dy] = t[temp.x][temp.y] + 1;
                    p.x = dx; p.y = dy; q.push(p);
                }
        }
    }
}
void BFS() {
    queue<Point> q;
    memset(d, 0x3f, sizeof d);
    d[x0][y0] = 0;
    p.x = x0; p.y = y0; q.push(p);
    while (!q.empty()) {
        Point temp = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int dx = temp.x + dir[i][0];
            int dy = temp.y + dir[i][1];
            if (check(dx, dy) && !vis[dx][dy])
                if (d[temp.x][temp.y] + 1 < t[dx][dy]) {
                    d[dx][dy] = d[temp.x][temp.y] + 1;
                    if (g[dx][dy] == 'D') return;
                    p.x = dx; p.y = dy; q.push(p);
                    vis[dx][dy] = 1;
                }
        }
    }
}
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            scanf(" %c", &g[i][j]);
            if (g[i][j] == 'S') x0 = i, y0 = j;
            if (g[i][j] == 'D') x1 = i, y1 = j;
        }
    memset(t, 0x3f, sizeof t);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (g[i][j] == '*') bfs(i, j);
    BFS();
    if (d[x1][y1] == inf) printf("KAKTUS\n");
    else printf("%d\n", d[x1][y1]);
    return 0;
}
```

