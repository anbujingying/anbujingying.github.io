---
title: 1381.删除
categories:
  - JZOJ
  - JZ高中OJ
tags:
	- OJ
---

Time Limits: 1000 ms  Memory Limits: 65536 KB

## Description

　　Alice上化学课时又分心了，他首先画了一个3行N列的表格，然后把数字1到N填入表格的第一行，保证每个数只出现一次，另外两行他也填入数字1到N，但不限制每个数字的出现次数。
　　Alice现在想删除若干列使得每一行排完序后完全一样，编程计算最少需要删除多少列。



## Input

　　第一行包含一个整数N(1<=N<=100000)，表示表格的列数。
　　接下来三行每行包含N个整数，每个数在1到N之间，而且第一行的数互不相同。

## Output

　　输出最少需要删除的列数。

## Sample Input

```
输入1：
7
5 4 3 2 1 6 7
5 5 1 1 3 4 7
3 7 1 4 5 6 2

输入2：
9
1 3 5 9 8 6 2 4 7
2 1 5 6 4 9 3 4 7
3 5 1 9 8 6 2 8 7
```

## Sample Output

```
输出1：
4

输出2：
2
```

Data Constraint

## Hint

【样例解释】
　　例1中Alice需要删除第2、4、6、7这四列，然后每行排完序都是1、3、5。
【数据范围】
　　40%的数据N<=100
　　70%的数据N<=10000

## Code

```cpp
#include <stdio.h>
#include <cmath>
#include<iostream>
#define fo() for(register int i=0;i<n;i++)
using namespace std;
int n,row1[100010],row2[100010],row3[100010],count2[100010],count3[100010],ans=0;
int main()
{
    cin>>n;
    fo(){
        cin>>row1[i];
    }
    fo(){
        cin>>row2[i];
        count2[row2[i]]++;
    }
    fo(){
        cin>>row3[i];
        count3[row3[i]]++;
    }
    register int flag=0;
    while(!flag){
        flag=1;
        fo()
        {
            if (row1[i]&&!(count2[row1[i]]&&count3[row1[i]])){
                flag=0;
                ans++;
                row1[i]=0;
                count2[row2[i]]--;
                count3[row3[i]]--;
            } 
        }
    }
    cout<<ans;
    return 0;
}
```

