---
title: '1574.X-因子链 '
categories:
  - JZOJ
  - JZ初中OJ
tags:
  - OJ
---

## input:**factor.in**   output:**factor.out**

时间限制: **1000 ms**  空间限制: **131072 KB**  

## 题目描述

给一个正整数X，一个长度为m的X-因子链是指这样一个序列：X0=1，X1，X2，。。。，Xm=X满足：Xi<Xi+1同时Xi**|**Xi+1(Xi+1能被Xi整除)

要求X-因子链的最大长度Len和长度为Len的X-因子链的数量。



## 输入

​     一个正整数X(X <231)

## 输出

​     一行，两个整数，分别表示最大长度和该长度链的种数。

## 样例输入

```
100
```

## 样例输出

```
4 6
```

## 数据范围限制



## 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef unsigned int uint;
const int maxp = 10000 + 5;
const int maxn = 1100000 + 5;
int sum,X;
int prime[maxp];
bool vis[maxn];
int num[maxp],k;
void init(){
    sum=0;
    memset(vis,true,sizeof(vis));
    for(int i=2;i<=maxn;i++){
        if(!vis[i]) continue;
        prime[sum++]=i;
        if(i>(int)sqrt(maxn)) continue;
        for(int j=i*i;j<=maxn;j+=i)
            vis[j]=false;
    }
}
ll get_max(){  
    ll ans=0;
    for(int i=0;i<k;i++)
        ans+=(ll)num[i];
    return ans;
}
ll get_sum(){  
    ll fenzi=1;
    ll Max=get_max();
    for(ll i=2;i<=Max;i++)
        fenzi*=i;
    for(int i=0;i<k;i++){
        for(int j=2;j<=num[i];j++){
            fenzi/=(ll)j;
        }
    }
    return fenzi;
}
void solve(){
    k=0;
    memset(num,0,sizeof(num));
    for(int i=0;i<sum;i++){
        if(X%prime[i]==0){
            while(X%prime[i]==0){
                num[k]++;
                X/=prime[i];
            }
            k++;
        }
        if(X==1){
            break;
        }
    }
    ll ans_max=get_max();
    ll ans_sum=get_sum();
    printf("%lld %lld\n",ans_max,ans_sum);
}
int main(){
	freopen("factor.in","r",stdin);
	freopen("factor.out","w",stdout);
    init();
    while(scanf("%d",&X)!=EOF){
        solve();
    }return 0;
}
```

