---
title: 3426.封印一击
categories:
  - JZOJ
  - JZ高中OJ
tags:
  - OJ
---

Time Limits: **1000 ms**  Memory Limits: **131072 KB** 

## Description

“圣主applepi于公元2011年9月创造了Nescafe，它在散发了16吃光辉之后与公元2011年11月12日被封印为一颗魂珠，贮藏于Nescafe神塔之中。公元2012年9月，圣主带领四大护法重启了Nescafe，如今已经是Nescafe之魂的第30吃传播了。不久，它就要被第二次封印，而变成一座神杯。。。”applepi思索着Nescafe的历史，准备着第二次封印。

Nescafe由n种元素组成(编号为1~n)，第i种元素有一个封印区[ai,bi]。当封印力度E小于ai时，该元素获得ai的封印能量；当封印力度E在ai到bi之间时，该元素将获得E的封印能量；而当封印力度E大于bi时，该元素将被破坏从而不能获得任何封印能量。现在圣主applepi想选择恰当的E，使得封印获得的总能量尽可能高。为了封印的最后一击尽量完美，就请你写个程序帮他计算一下吧！



## Input

第一行一个整数N。

接下来N行每行两个整数ai、bi，第i+1行表示第i种元素的封印区间。

## Output

两个用空格隔开的证书，第一个数十能够获得最多总能量的封印力度E，第二个数是获得的总能量大小。当存在多个E能够获得最多总能量时，输出最小的E。

## Sample Input

```
2
5 10
20 25
```

## Sample Output

```
10 30
```

## Data Constraint

对于50%的数据，1<=N<=1000，1<=ai<=bi<=10000。

对于100%的数据，1<=N<=10^5,1<=ai<=bi<=10^9。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=100005;
struct qj{int v,l;}k[maxn*2];
bool cmp(qj a,qj b){return a.v<b.v||a.v==b.v&&a.l>b.l;}
int a,b,n,ansn;
long long al,m,ans;
void init()
{
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d%d",&a,&b);
        k[i*2-1].v=a;k[i*2-1].l=1;
        k[i*2].v=b;k[i*2].l=2;
        al=al+a;
    }
}
int main()
{
    init();
    sort(k+1,k+1+2*n,cmp);
    for(int i=1;i<=2*n;i++)
    { 
        long long sum=0;
        if (k[i].l==1)
        {
            al-=k[i].v;
            m++;
            sum=al+m*k[i].v;
            if (sum>ans) 
            {
                ansn=k[i].v;
                ans=sum;
            }
        }
        else
        {
            sum=al+m*k[i].v;
            if (sum>ans) 
            {
                ansn=k[i].v;
                ans=sum;
            }
            m--;
        }
    }
    printf("%d %lld",ansn,ans);
    return 0;
}
```

