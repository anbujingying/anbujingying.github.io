---
title: 1038.游戏
categories:
  - JZOJ
  - JZ高中OJ
tags:
  - OJ
---

Time Limits: 1000 ms  Memory Limits: 65536 KB  

## Description

windy学会了一种游戏。 对于1到N这N个数字，都有唯一且不同的1到N的数字与之对应。 最开始windy把数字按顺序1，2，3，……，N写一排在纸上。 然后再在这一排下面写上它们对应的数字。 然后又在新的一排下面写上它们对应的数字。 如此反复，直到序列再次变为1，2，3，……，N。 如： 1 2 3 4 5 6 对应的关系为 1->2 2->3 3->1 4->5 5->4 6->6 windy的操作如下

1 2 3 4 5 6

2 3 1 5 4 6

3 1 2 4 5 6

12 3 5 4 6

2 3 1 4 5 6

3 1 2 5 4 6

1 2 3 4 5 6

这时，我们就有若干排1到N的排列，上例中有7排。 现在windy想知道，对于所有可能的对应关系，有多少种可能的排数。



## Input

一个整数，N。

## Output

一个整数，可能的排数。

## Sample Input

```
3
```

## Sample Output

```
3
```

## Data Constraint

 

## Hint

100%的数据，满足 1 <= N <= 1000 。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
long long dp[1039][1039],tot,ans;
int main()
{
    long long n,a,b,c;
    scanf("%lld",&n);
    dp[0][0]=1;
    for(a=2;a<=n;a++)
    {
        for(b=2;b<a;b++)
        {
            if(a%b==0)
            {
                break;
            }
        }
        if(b==a)
        {
            for(b=0;b<=n;b++)
            {
                dp[tot+1][b]+=dp[tot][b];
                for(c=a;b+c<=n;c*=a)
                {
                    dp[tot+1][b+c]+=dp[tot][b];
                }
            }
            tot++;
        }
    }
    for(int a=0;a<=n;a++)
    {
        ans+=dp[tot][a];
    }
    printf("%lld",ans);
    return 0;
}
```

