---
title: 1385.直角三角形
categories:
  - JZOJ
  - JZ高中OJ
tags:
  - OJ
---

Time Limits: 4000 ms  Memory Limits: 65536 KB 

## Description

二维平面坐标系中有N个点。
从N个点选择3个点，问有多少选法使得这3个点形成直角三角形。



## Input

第一行包含一个整数N(3<=N<=1500)，表示点数。
接下来N行，每行包含两个用空格隔开的整数表示每个点的坐标，坐标值在-10^9到10^9之间。
每个点位置互不相同。

## Output

输出直角三角形的数量。

## Sample Input

```
输入1：
3
4 2
2 1
1 3

输入2：
4
5 0
2 6
8 6
5 7

输入3：
5
-1 1
-1 0
0 0
1 0
1 1
```

## Sample Output

```
输出1：
1

输出2：
0

输出3：
7
```

## Code

```cpp
#include <bits/stdc++.h>    
using namespace std;
struct arr{
    long long x,y;
    int cover;
}tu[1505],f[1505];
int ans[5];
int x[1505],y[1505];
int n,sum;
int cmp(arr a,arr b){
    return a.x*b.y>a.y*b.x;
}

int rt90(int o){
    long long t;
    t=tu[o].x;
    tu[o].x=tu[o].y;
    tu[o].y=-t;
    tu[o].cover+=1; tu[o].cover%=4;
}

int merge(int x,int y)
{
    if (x!=y){
        int mid=(x+y)/2;
        merge(x,mid);
        merge(mid+1,y);
        memset(f,0,sizeof(f));
        int i=x,k=x;
        int j=mid+1;
        while (i<=mid&&j<=y){
            if (tu[i].y*tu[j].x<tu[i].x*tu[j].y){
                f[k]=tu[i];
                i+=1;
            } else {
                f[k]=tu[j];
                j+=1;
            }
            k+=1;
        }
        while (i<=mid){
            f[k]=tu[i];
            i+=1; k+=1;
        }
        while (j<=y){
            f[k]=tu[j];
            j+=1; k+=1;
        }
        for (int i=x;i<=y;i++)
            tu[i]=f[i];
    }
}

int main(){
    scanf("%ld",&n);
    for (int i=1;i<=n;i++)
        scanf("%ld%ld",&x[i],&y[i]);
    sum=0;
    for (int i=1;i<=n;i++){
        for (int j=1;j<=n;j++){
            tu[j].x=x[j]-x[i];
            tu[j].y=y[j]-y[i];
            tu[j].cover=0;
            if (i==j){
                tu[j].x=tu[1].x;
                tu[j].y=tu[1].y;
                tu[j].cover=tu[1].cover;
            } else
            while (!((tu[j].x>0)&&(tu[j].y>=0)))
                rt90(j);    
        }
        merge(2,n);
        int j=2;
        while (j<=n){
            memset(ans,0,sizeof(ans));
            int k=j;
            while ((k<=n)&&(tu[j].y*tu[k].x==tu[j].x*tu[k].y)){
                ans[tu[k].cover]+=1;
                k+=1;
            }
            j=k;
            for (int o=0;o<=3;o++)
                sum+=ans[o]*ans[(o+1)%4];
        }
    }
    printf("%ld",sum);
}
```

