---
title: 1035.粉刷匠
categories:
  - JZOJ
  - JZ高中OJ
tags:
  - OJ
---

Time Limits: 5000 ms  Memory Limits: 65536 KB  

## Description

windy有 N 条木板需要被粉刷。
每条木板被分为 M 个格子。
每个格子要被刷成红色或蓝色。
windy每次粉刷，只能选择一条木板上一段连续的格子，然后涂上一种颜色。
每个格子最多只能被粉刷一次。
如果windy只能粉刷 T 次，他最多能正确粉刷多少格子？
一个格子如果未被粉刷或者被粉刷错颜色，就算错误粉刷。



## Input

第一行包含三个整数，N M T。
接下来有N行，每行一个长度为M的字符串，'0'表示红色，'1'表示蓝色。

## Output

输出一个整数，表示最多能正确粉刷的格子数。

## Sample Input

```
3 6 3
111111
000000
001100
```

## Sample Output

```
16
```

## Data Constraint

 

## Hint

100%的数据，满足 1 <= N,M <= 50 ； 0 <= T <= 2500 。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
inline int read()
{
    int x=0;char ch=getchar();
    while(ch<'0'||ch>'9')ch=getchar();
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x;
}
int n,m,t,ans;
int sum[55];
int f[55][55],dp[55][2505];
char s[60];
int main()
{
    n=read();
    m=read();
    t=read();
    for(int i=1;i<=n;i++)
    {
        scanf("%s",s+1);
        for(int j=1;j<=m;j++)
            sum[j]=sum[j-1]+(s[j]=='1');
        for(int j=1;j<=m;j++)
            for(int x=1;x<=m;x++)
           {
                f[x][j]=0;
                for(int y=0;y<x;y++)
        {
            int tmp=sum[x]-sum[y];
            f[x][j]=max(f[x][j],f[y][j-1]+max(tmp,x-y-tmp));
        }
            }
        for(int j=1;j<=t;j++)
        {
            int tmp=min(m,j);
            for(int k=1;k<=tmp;k++)
                dp[i][j]=max(dp[i][j],dp[i-1][j-k]+f[m][k]);
        }
    }
    for(int i=1;i<=t;i++)
        ans=max(dp[n][i],ans);
    printf("%d",ans);
    return 0;
}
```



  