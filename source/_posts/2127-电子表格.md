---
title: '2127.电子表格'
categories:
  - JZOJ
  - JZ初中OJ
tags:
  - OJ
---

## input:**excel.in**   output:**excel.out**

时间限制: **1000 ms**  空间限制: **262144 KB** 

## 题目描述

也许你用过Microsoft Excel之类的电子制表软件，这类软件最令人称道的就是强大的公式计算功能。现在希望你也来实现一个具有最基本功能的电子制表软件。表格共有m列(0 < m • 26)，从左到右依次用A到Z的大写英文字母表示；有n行(0 < n <100)，从上到下依次用1到100的整数表示。这样，每一个单元格的位置就可以唯一地用它所在的列和行表示出来，例如从左到右第3列，从上到下第5行的单元格就可以用“ C5”来表示（注意，这里字母和数字中间没有空格）。
现在对表格进行了一系列的操作，这些操作主要就是赋值和查询。定义操作的输入规则
如下：
1.每个操作占一行，根据操作类型的不同，每行中可能有二至四个用空格隔开的“单词”；
2.每行的第一个单词指定了该操作涉及的单元格的位置；
3.每行的第二个单词指定了相应的操作，可能是： input,output,sum,avg
(1).如果第二个单词是input，表示接下来的一个整数是要赋予该单元格的值，这个值是
不超过1000的正整数
(2).如果第二个单词是output，表示你需要在输出文件中输出这个单元格当前的值
(3).如果第二个单词是sum，表示接下来输入的两个单词定义了一个矩形区域，该单元格的值就应该恒为这个矩形区域中所包含的单元格的值的和，直到该单元格被重新定义
(4).如果第二个单词是avg，表示接下来输入的两个单词定义了一个矩形区域，该单元格的值就应该恒为这个矩形区域中所包含的单元格的值的算术平均数，直到该单元格被重新定义；
4.“输入的两个单词定义了一个矩形区域”是指输入一个矩形区域的左上角和右下角的单元格的位置，这样就唯一确定了这个矩形区域；
5.所有时刻，每个单元格的值均为整数，如果不是，则向下取整；
6.如果某个单元格的值没有在上文定义，则它的值默认为0；
7.不会出现循环定义的情况；
8.在操作过程中所有单元格的值不超过231-1。
 

## 输入

第一行输入两个用空格隔开的正整数m和n，分别代表表格的列数和行数。
第二行输入一个正整数s，表示操作的总数。
以下s行每行输入一个操作，具体格式参见问题描述。

## 输出

对于输入数据的每一个“ output”操作输出一行结果。因此，输出文件的行数等于输入文件中“ output”操作的个数。

## 样例输入

```
3 5
5
A1 input 100
B2 input 200
C3 sum A1 C2 
C5 avg B2 C4
C5 output 
```

## 样例输出

```
83 
```

## 数据范围限制

对于30%的数据， m; n; s <= 10；对于100%的数据， m <= 26， n < =100， s <=100。

## 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<sstream>
#include<cstring>
using namespace std;
struct node{
	int x1,y1,x2,y2;
}c[10001];
stringstream ss;
string s1,s2,s3,s4;
int tt,x,y,x1,y1,x2,y2,s,t,n,m,k,i,j,a[101][101],b[101][101]={0},m1=0,m2=1;
int avg(int m2);
int sum(int m1){
	int t=0;
	for (int i=c[m1].x1;i<=c[m1].x2;i++) {
		for (int j=c[m1].y1;j<=c[m1].y2;j++) {
			if (b[i][j]!=0) {
				if (b[i][j]%2==0){
					 a[i][j]=sum(b[i][j]); 
				}else{
					 a[i][j]=avg(b[i][j]);
				}
			}
			t+=a[i][j];
		} 	
	} 
	return t;
}
int avg(int m2){ 
	int t=0,tt=0;
	for (int i=c[m2].x1;i<=c[m2].x2;i++) {
		for (int j=c[m2].y1;j<=c[m2].y2;j++) {
			if (b[i][j]!=0) {
				if (b[i][j]%2==0){
					 a[i][j]=sum(b[i][j]);
				}else {
					a[i][j]=avg(b[i][j]);
				}
			}
			t++;
			tt+=a[i][j];
		} 	
	} 
	return tt/t;
}
int main()
{
	freopen("excel.in","r",stdin);
	freopen("excel.out","w",stdout);
	cin>>m>>n>>s;
	for (i=1;i<=s;i++) {
		cin>>s1>>s2;
		y=s1[0]-64;
		s1.erase(0,1);ss.clear();
	 	ss<<s1;
		ss>>x;
		if (s2=="input") {
		   cin>>s3;
		   ss.clear();
		   ss<<s3;
		   ss>>a[x][y];
		   b[x][y]=0;
		} else if (s2=="output") {
			if (b[x][y]!=0) {
				if (b[x][y]%2==0){
					 a[x][y]=sum(b[x][y]); 
				}else {
					a[x][y]=avg(b[x][y]);
				}
			}
			cout<<a[x][y]<<endl;
		} else {
			cin>>s3>>s4;
			y1=s3[0]-64;
			s3.erase(0,1);
			ss.clear();
			ss<<s3;
			ss>>x1;
			y2=s4[0]-64;
			s4.erase(0,1);
			ss.clear();
			ss<<s4;
			ss>>x2;
			if (s2=="sum") {
				m1+=2;
   				b[x][y]=m1;
				c[m1].x1=x1;
				c[m1].y1=y1;
				c[m1].x2=x2;
				c[m1].y2=y2;
			} else if (s2=="avg") {
   			    m2+=2;
   				b[x][y]=m2;
				c[m2].x1=x1;
				c[m2].y1=y1;
				c[m2].x2=x2;
				c[m2].y2=y2;
			}
		}
	}
}
```

