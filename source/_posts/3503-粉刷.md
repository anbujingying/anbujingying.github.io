---
title: 3503.粉刷
categories:
  - JZOJ
  - JZ高中OJ
tags:
  - OJ
---

Time Limits: **1000 ms**  Memory Limits: **131072 KB** 

## Description

鸡腿想到了一个很高（sha）明（bi）的问题，墙可以看作一个N*M的矩阵，有一些格子是有污点的。现在鸡腿可以竖着刷一次，覆盖连续的最多C列，或者横着刷一次，覆盖连续的最多R行。现在鸡腿把墙上的情况告诉你，请你告诉鸡腿最少要刷多少次才能刷干净！



## Input

第1行，输入俩正整数N，M。

第2到N+1行，每行一个长度为M的字符串，每个字符可能是’.’表示干净的，或者’X’表示这个格子有污点。

第N+2行，输入俩正整数表示R和C。

## Output

输出一行一个整数，表示鸡腿最少要刷几次。

## Sample Input

```
输入1：
1 9
XXXXXXXXX
2 3
输入2：

11 14
XXX..XXX..XXX.
.X..X....X...X
.X..X....X...X
.X..X....X...X
.X...XXX..XXX.
..............
...XX...XXX...
....X......X..
....X....XXX..
....X......X..
...XXX..XXX...
1 2
```

## Sample Output

```
输出1：
1
输出2：
7
```

## Data Constraint

对于50%的数据1≤N，M≤5；

对于100%的数据1≤N，M，R，C≤15。

## Code

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,r,c,i,j,ans=0;
bool bz1[15],bz2[15];
char s[15][15];                                       
void dg(int t,int sum)
{
    int i,j;
    if(t>n)
    {
        memset(bz2,false,sizeof(bz2));
        for(j=1;j<=m;j++)
            for(i=1;i<=n;i++)
                if(!bz1[i]&&s[i][j]=='X'){
                	 bz2[j]=true;
				}
        for(i=1;i<=m;i++)
            if(bz2[i])
            {
                for(j=1;j<=c;j++){
                	 bz2[min(j+i-1,m)]=false;
				}
                sum++;
            }   
        if(sum<ans){
        	ans=sum;
		}
        return;
    }
    if(!bz1[t])
    {
        for(i=1;i<=r;i++){
        	 bz1[min(i+t-1,n)]=true;
		}
        dg(t+1,sum+1);
        for(i=1;i<=r;i++){
        	 bz1[min(i+t-1,m)]=false;   
		}
    }
    dg(t+1,sum);
}
int main()
{
    scanf("%d%d\n",&n,&m);
    for(i=1;i<=n;i++)
    {
        for(j=1;j<=m;j++){
        	 scanf("%c",&s[i][j]);
		}
        scanf("\n");
    }
    scanf("%d%d",&r,&c);
    ans=2147483647;
    dg(1,0);
    printf("%d",ans);  
}
```

